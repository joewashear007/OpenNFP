@inject IChartingRepo Repo
@inject ICycleChartGenerator Generator
@inject NavigationManager MyNavigationManager
@inject IJSRuntime JsRuntime
@inject ILogger<CycleChart> Logger
@implements IDisposable

@using OpenNFP.Client.Utils
@using Plotly.Blazor
@using Plotly.Blazor.LayoutLib
@using Plotly.Blazor.Traces
@using Plotly.Blazor.Traces.ScatterLib
@using System.Globalization



<MudCard>
    <MudCardHeader>
        <MudChip Label="true">Cycle @CycleIndex</MudChip>
        <MudChip Label="true">
            @Cycle.Length Days
            @if (LimitDays && Cycle.Length > 40)
            {
                <MudIcon Icon="@Icons.Material.Filled.WarningAmber" />
            }
        </MudChip>
        <MudText Align="Align.Center" Typo="Typo.subtitle1"></MudText>
        <MudText Typo="Typo.h6" Align="Align.Center">@(Cycle?.StartDate.ToString("MMM dd yyyy") ?? " -- -- ----")</MudText>
            @if (LimitDays)
        {
            <MudIconButton Href="@(MyNavigationManager.BaseUri + "/cycle/" + Cycle?.StartDate.ToKey())" Icon="@Icons.Material.Filled.OpenWith"></MudIconButton>
        }
    </MudCardHeader>
    <MudCardContent Class="p-0">

        @if (Cycle.Length < 5 && Repo.Settings.EndDate != Cycle.EndDate)
        {
            <MudAlert Severity="Severity.Warning">
                This chart is too short! <br />
                <MudButtonGroup Color="Color.Warning" Variant="Variant.Text">
                    <MudButton OnClick="() => MergeCycle(below:false)">Merge With Above Cycle</MudButton>
                    <MudButton OnClick="() => MergeCycle(below:true)">Merge with Below Cycle</MudButton>
                </MudButtonGroup>
            </MudAlert>
        }
        @if (Loading)
        {
            if (RenderChart)
            {
                <MudSkeleton keletonType="SkeletonType.Rectangle" Width="100%" Height="60px" />
                <MudSkeleton keletonType="SkeletonType.Rectangle" Width="100%" Height="200px" />
                <MudSkeleton keletonType="SkeletonType.Rectangle" Width="100%" Height="100px" />
                <MudSkeleton keletonType="SkeletonType.Rectangle" Width="100%" Height="100px" />
            }
        }
        else
        {
            <div style="@(LimitDays ? "overflow-x:scroll; overflow-y:hidden;" : "") padding-bottom:20px @(RenderChart ?"":  "display:none")">

                <PlotlyChart @bind-Config="config"
                         @bind-Layout="layout"
                         @bind-Data="data"
                         @ref="chart" />
            </div>
        }

        @if (!RenderChart)
        {
            <MudButton OnClick="() => RenderChart = true">Load Chart</MudButton>
        }
    </MudCardContent>
</MudCard>


@code {
    [Parameter, EditorRequired]
    public Cycle Cycle { get; set; } = null!;

    [Parameter, EditorRequired]
    public int CycleIndex { get; set; }

    [Parameter]
    public bool LimitDays { get; set; } = false;

    [Parameter]
    public bool RenderChart { get; set; } = true;


    private bool firstRenderComplete = false;
    private bool updateChart = false;
    public bool Loading { get; set; } = true;
    private PlotlyChart? chart;
    private DotNetObjectReference<CycleChart>? _chartRef;
    private Config config = new()
        {
            Responsive = false,
            StaticPlot = false,
            DisplayLogo = false,
            DoubleClick = DoubleClickEnum.False,
            Editable = false,
            ShowAxisDragHandles = false,
            ShowEditInChartStudio = false,
            ShowSources = false,
            Watermark = false,
            DisplayModeBar = DisplayModeBarEnum.False,
            FrameMargins = 0,
            ScrollZoom = ScrollZoomFlag.False
        };
    private readonly List<object> colorScale = new List<object>()
    {
        new List<object>() {0.0 , MudBlazor.Colors.DeepPurple.Lighten5 },
        new List<object>() {0.1 , MudBlazor.Colors.DeepPurple.Lighten5 },

        new List<object>() {0.1 , MudBlazor.Colors.DeepPurple.Lighten2 },
        new List<object>() {0.3 , MudBlazor.Colors.DeepPurple.Lighten2 },

        new List<object>() { 0.3, MudBlazor.Colors.DeepPurple.Darken1 },
        new List<object>() { 0.6, MudBlazor.Colors.DeepPurple.Darken1 },

        new List<object>() { 0.6, MudBlazor.Colors.DeepPurple.Darken3 },
        new List<object>() { 1.0, MudBlazor.Colors.DeepPurple.Darken3 },

    };

    private readonly List<object> mensColorScale = new List<object>()
    {
        new List<object>() {0.0 , MudBlazor.Colors.Teal.Lighten5 },
        new List<object>() {0.1 , MudBlazor.Colors.Teal.Lighten5 },

        new List<object>() {0.1 , MudBlazor.Colors.Teal.Lighten2 },
        new List<object>() {0.3 , MudBlazor.Colors.Teal.Lighten2 },

        new List<object>() { 0.3, MudBlazor.Colors.Teal.Darken1 },
        new List<object>() { 0.6, MudBlazor.Colors.Teal.Darken1 },

        new List<object>() { 0.6, MudBlazor.Colors.Teal.Darken3 },
        new List<object>() { 1.0, MudBlazor.Colors.Teal.Darken3 },

    };

    private readonly Plotly.Blazor.LayoutLib.AnnotationLib.Font font = new() { Color = "white", Size = 12, Family = "symbolaregular, Symbola" };


    private IList<ITrace> data { get; set; } = new List<ITrace>();

    private Layout layout = new Layout()
        {
            YAxis = new List<YAxis> {
            new()
            {
                Title = new Plotly.Blazor.LayoutLib.YAxisLib.Title { Text = "Temp" },
                Domain = new List<object>() {0M, 0.25}
            },
            new()
            {
                Domain = new List<object>() {0.30, 0.65},
                GridWidth  =1,

            },
            new()
            {
                Domain = new List<object>() {0.675, 0.80},
                GridWidth  =1,

            },
            new()
            {
                Domain = new List<object>() {0.85, 1},
                GridWidth  =1,

            }
        },
            XAxis = new List<XAxis>()
        {
            new XAxis()
            {
                Domain = new List<object>(){ 0,1 },
                TickFormat = "%a %m/%d",
                TickAngle = 90,
                DTick = 86400000,
                Type = Plotly.Blazor.LayoutLib.XAxisLib.TypeEnum.Date,
            }
        },
            ClickMode = ClickModeFlag.Event,
            DragMode = DragModeEnum.False,
            Annotations = new List<Annotation>(),
            AutoSize = true,
            Margin = new Plotly.Blazor.LayoutLib.Margin() { AutoExpand = true, Pad = 0, T = 1 },
            Height = 500,
        };


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        Logger.LogInformation($"CycleChart Render: {nameof(firstRender)} {firstRender}, {nameof(firstRenderComplete)} {firstRenderComplete}, {nameof(RenderChart)} {RenderChart}, {nameof(updateChart)} {updateChart}");

        if (updateChart)
        {
            updateChart = false;
            if (chart is not null)
            {
                await chart.React();

                if (_chartRef == null)
                {
                    _chartRef = DotNetObjectReference.Create(this);
                    await JsRuntime.SubscribeClickEvent(_chartRef, chart.Id);
                }
            }
            else
            {
                Logger.LogWarning($"Cycle Chart is Null!");
            }

        }

        if (!firstRenderComplete && RenderChart)
        {
            firstRenderComplete = true;
            await SetupChart();
        }

    }

    protected override void OnParametersSet()
    {
        int maxCycleLength = Math.Max(Cycle?.Length ?? 0, 10);
        if (LimitDays)
        {
            maxCycleLength = Math.Min(maxCycleLength, 40);
        }
        layout.Width = maxCycleLength * 50;
        layout.XAxis[0].Range = new List<object> { Cycle.StartDate.AddHours(-12).ToString("yyyy-MM-dd"), Cycle.StartDate.AddDays(maxCycleLength).ToString("yyyy-MM-dd"), };
        layout.XAxis[0].Tick0 = Cycle.StartDate.ToString("yyyy-MM-dd");
    }

    private async Task SetupChart()
    {
        Logger.LogInformation($" Cycle {Cycle?.StartDate.ToKey()} - Loading Data");
        if (Cycle != null)
        {
            CycleViewMode viewModel = await Generator.GetTracesAsync(Cycle.StartDate, LimitDays);
            List<object> dayColorScale = new List<object>()
            {
                new List<object>() {0, MudBlazor.Colors.Lime.Darken3},
                new List<object>() {viewModel.PhaseStartDays[1], MudBlazor.Colors.Lime.Darken3},

                new List<object>() {viewModel.PhaseStartDays[1], MudBlazor.Colors.Green.Darken3 },
                new List<object>() {viewModel.PhaseStartDays[2], MudBlazor.Colors.Green.Darken3 },

                new List<object>() {viewModel.PhaseStartDays[2], MudBlazor.Colors.Cyan.Darken3},
                new List<object>() {1, MudBlazor.Colors.Cyan.Darken3},
            };



            Scatter tempTrace = new Scatter
                {
                    Mode = ModeFlag.Lines | ModeFlag.Markers,
                    X = viewModel.Days,
                    Y = viewModel.Temp.Values,
                    YAxis = "y",
                    ShowLegend = false,
                };

            HeatMap hm = new HeatMap()
                {
                    X = viewModel.Days,
                    Y = new List<object>() { "Monitor", "Cervix", "Mucus" },
                    Z = new List<object>() {
                            viewModel.Monitor.Values,
                            viewModel.Cervix.Values,
                            viewModel.Mucus.Values,
                        },
                    ShowLegend = false,
                    YAxis = "y2",
                    ShowScale = false,
                    XGap = 3,
                    YGap = 1,
                    ColorScale = colorScale
                };
            HeatMap mensHm = new HeatMap()
                {
                    X = viewModel.Days,
                    Y = new List<object>() { "Mens" },
                    Z = new List<object>() {
                            viewModel.Mens.Values,
                        },
                    ShowLegend = false,
                    YAxis = "y3",
                    ShowScale = false,
                    XGap = 3,
                    YGap = 1,
                    ColorScale = mensColorScale
                };
            HeatMap hmDate = new HeatMap()
                {
                    X = viewModel.Days,
                    Y = new List<object>() { "Day" },
                    Z = new List<object>() {
                            viewModel.Index.Values
                        },
                    ShowLegend = false,
                    YAxis = "y4",
                    ShowScale = false,
                    XGap = 3,
                    YGap = 1,
                    ColorScale = dayColorScale,
                    AutoColorScale = false,
                    ZMin = 0,
                    ZMax = viewModel.Days.Count
                };


            data.Add(tempTrace);
            data.Add(hm);
            data.Add(mensHm);
            data.Add(hmDate);
            layout.Annotations.AddRange(viewModel.Monitor.Annotations
                .Select((q, i) => new Annotation() { XRef = "x1", YRef = "y2", X = viewModel.Days[i], Y = 0, Text = q, ShowArrow = false, Font = font }));
            layout.Annotations.AddRange(viewModel.Cervix.Annotations
                .Select((q, i) => new Annotation() { XRef = "x1", YRef = "y2", X = viewModel.Days[i], Y = 1, Text = q, ShowArrow = false, Font = font }));
            layout.Annotations.AddRange(viewModel.Mucus.Annotations
                .Select((q, i) => new Annotation() { XRef = "x1", YRef = "y2", X = viewModel.Days[i], Y = 2, Text = q, ShowArrow = false, Font = font }));
            layout.Annotations.AddRange(viewModel.Mens.Annotations
                .Select((q, i) => new Annotation() { XRef = "x1", YRef = "y3", X = viewModel.Days[i], Y = 0, Text = q, ShowArrow = false, Font = font }));
            layout.Annotations.AddRange(viewModel.Index.Annotations
                .Select((q, i) => new Annotation() { XRef = "x1", YRef = "y4", X = viewModel.Days[i], Y = 0, Text = q, ShowArrow = false, Font = font, }));

            updateChart = true;
            Loading = false;
            StateHasChanged();

        }
        else
        {
            throw new InvalidOperationException("NULL DATE ON CYCLE");
        }
    }

    private void MergeCycle(bool below)
    {
        if (below)
        {
            Repo.DeleteCycleAsync(Cycle.StartDate.ToKey());
        }
        else
        {
            var cycleToRemove = Repo.Cycles.FirstOrDefault(q => q.Index == CycleIndex + 1);
            if (cycleToRemove is not null && cycleToRemove.Item is not null)
            {
                Repo.DeleteCycleAsync(cycleToRemove.Item.StartDate.ToKey());
            }
        }
    }

    /// <summary>
    /// Method which is called by JSRuntime once a plot has been clicked, to invoke the passed in Action
    /// Objects are currently required for accomodating different plot value types
    /// </summary>
    /// <param name="index"></param>
    [JSInvokable("ClickEvent")]
    public void ClickEvent(int index)
    {
        //var i = Convert.ToInt32(index);
        Logger.LogDebug($"BLAZOR: click event: {index} ");
        var d = Cycle.StartDate.AddDays(index).ToKey() ?? "";
        if (!string.IsNullOrEmpty(d))
        {
            MyNavigationManager.NavigateTo(MyNavigationManager.BaseUri + "/editday/" + d);
        }
    }

    /// <inheritdoc />
    public void Dispose()
    {
        _chartRef?.Dispose();
        chart?.Dispose();
    }
}
